# class TransactionPool:
#     def __init__(self):
#         self.transaction_map = {}

#     def set_transaction(self, transaction):
#         """
#         Set a transaction in the transaction pool.
#         """
#         self.transaction_map[transaction.id] = transaction

#     def existing_transaction(self, address):
#         """
#         Find a transaction generated by the address in the transaction pool
#         """
#         for transaction in self.transaction_map.values():
#             if transaction.input["address"] == address:
#                 return transaction

#     def transaction_data(self):
#         """
#         Return the transactions of thje transaction pool represented in their
#         json serialized form.
#         """
#         return list(
#             map(
#                 lambda transaction: transaction.to_json(), self.transaction_map.values()
#             )
#         )

#     def clear_blockchain_transactions(self, blockchain):
#         """
#         Delete blockchain recorded transactions from the transaction pool.
#         """
#         for block in blockchain.chain:
#             for transaction in block.data:
#                 try:
#                     del self.transaction_map[transaction["id"]]
#                 except KeyError:
#                     pass

#     def to_json(self):
#         """
#         Return the transaction pool in JSON-serializable form.
#         """
#         return {"transactions": self.transaction_data()}

# transaction_pool.py
import time
from typing import Optional, Callable, Dict, List

# import your Transaction class
from .transaction import Transaction

class TransactionPool:
    """
    Transaction pool that supports:
      - nested outputs: { address: { currency: amount, ... }, ... }
      - asset-related transactions (listing, purchase, direct transfer)
      - simple per-asset reservation (asset_locks) to prevent local double-acceptance
      - validation on insert (optional callback to resolve asset)
    """

    def __init__(self, resolve_asset_fn: Optional[Callable[[str], object]] = None, validate_on_set: bool = True):
        # main id -> Transaction object map
        self.transaction_map: Dict[str, object] = {}

        # asset_id -> tx_id mapping to reserve an asset for a pending purchase in this pool
        self.asset_locks: Dict[str, str] = {}

        # optional function(asset_id) -> Asset object for server-side validation
        self.resolve_asset_fn = resolve_asset_fn

        # whether to run Transaction.is_valid_transaction on set()
        self.validate_on_set = validate_on_set

        # optional timestamp mapping for expiry (tx_id -> ts)
        self._timestamps: Dict[str, float] = {}

    # ---------------------
    # Core mutators
    # ---------------------
    def set_transaction(self, transaction) -> None:
        """
        Accept a Transaction object and add to pool.

        Raises:
            Exception on invalid tx or asset conflict.
        """
        tx_id = transaction.id

        # 1) Basic validation (sig, balance conservation etc.)
        if self.validate_on_set:
            # pass resolve_asset_fn so purchases can be checked against authoritative asset owner
            try:
                Transaction.is_valid_transaction(transaction, resolve_asset_fn=self.resolve_asset_fn)
            except Exception as e:
                raise Exception(f"Rejected transaction {tx_id}: validation failed: {e}")

        # 2) If tx refers to an asset purchase, check asset lock & ownership
        asset_info = None
        if getattr(transaction, "metadata", None):
            asset_info = transaction.metadata.get("asset_purchase") or transaction.metadata.get("asset_listing") or transaction.metadata.get("asset_transfer")

        # asset_purchase metadata expected shape: { "asset_id": "...", "from": "...", "to": "...", ... }
        if asset_info and "asset_id" in asset_info:
            aid = asset_info["asset_id"]
            # If pool already reserved this asset for a different tx -> reject
            existing = self.asset_locks.get(aid)
            if existing and existing != tx_id:
                raise Exception(f"Asset {aid} already reserved by tx {existing} in the pool")
            # Optionally confirm seller/owner if resolver is available
            if self.resolve_asset_fn is not None and "from" in asset_info:
                asset_obj = self.resolve_asset_fn(aid)
                if asset_obj is None:
                    raise Exception(f"Asset {aid} not found for tx {tx_id}")
                if asset_obj.owner != asset_info["from"]:
                    raise Exception(f"Asset owner mismatch: expected {asset_info['from']}, got {asset_obj.owner}")

            # reserve the asset for this tx
            self.asset_locks[aid] = tx_id

        # 3) Insert/update the tx
        self.transaction_map[tx_id] = transaction
        self._timestamps[tx_id] = time.time()

    def existing_transaction(self, address: str):
        """
        Find a transaction generated by the address in the transaction pool.
        Also consider transactions that include the address in asset metadata
        (e.g., seller listing or buyer purchase).
        """
        for transaction in self.transaction_map.values():
            try:
                if transaction.input and transaction.input.get("address") == address:
                    return transaction
                # check metadata involvement
                meta = getattr(transaction, "metadata", None) or {}
                # buyer/seller fields in asset metadata
                ap = meta.get("asset_purchase")
                if ap and (ap.get("from") == address or ap.get("to") == address):
                    return transaction
                al = meta.get("asset_listing")
                if al and al.get("owner") == address:
                    return transaction
                at = meta.get("asset_transfer")
                if at and (at.get("from") == address or at.get("to") == address):
                    return transaction
            except Exception:
                continue
        return None

    def get_transactions_by_asset(self, asset_id: str) -> List[object]:
        """Return transactions in the pool referencing this asset_id (purchase/listing/transfer)."""
        res = []
        for tx in self.transaction_map.values():
            meta = getattr(tx, "metadata", None) or {}
            for key in ("asset_purchase", "asset_listing", "asset_transfer"):
                v = meta.get(key)
                if v and v.get("asset_id") == asset_id:
                    res.append(tx)
                    break
        return res

    def remove_transaction(self, tx_id: str) -> None:
        """
        Remove tx from pool and release any asset locks it held.
        """
        tx = self.transaction_map.pop(tx_id, None)
        self._timestamps.pop(tx_id, None)
        if not tx:
            return

        # release related asset lock if exists
        meta = getattr(tx, "metadata", None) or {}
        for key in ("asset_purchase", "asset_listing", "asset_transfer"):
            v = meta.get(key)
            if v and "asset_id" in v:
                aid = v["asset_id"]
                # only remove lock if it was set to this tx id (safety)
                if self.asset_locks.get(aid) == tx_id:
                    del self.asset_locks[aid]

    def clear_blockchain_transactions(self, blockchain) -> None:
        """
        Remove transactions that are now recorded in the chain and free locks.
        Works with blocks structured such that block.data contains tx json dicts.
        """
        for block in blockchain.chain:
            for tx_json in block.data:
                try:
                    txid = tx_json["id"]
                except Exception:
                    # If block stores raw tx dict without id, skip
                    txid = tx_json.get("id")
                if not txid:
                    continue
                # Attempt removal
                try:
                    self.remove_transaction(txid)
                except Exception:
                    # ignore missing or mismatched entries
                    pass

    # ---------------------
    # Helpers & exporters
    # ---------------------
    def transaction_data(self):
        """
        Return list of transactions in json-serializable form.
        """
        return list(map(lambda t: t.to_json(), self.transaction_map.values()))

    def to_json(self):
        """
        Pool dump
        """
        return {"transactions": self.transaction_data()}

    def get_transactions_for_mining(self, limit: Optional[int] = None) -> List[object]:
        """
        Return a list of validated transactions for inclusion in next block.
        - Currently FIFO by insertion timestamp; later you can sort by fee or priority.
        - Does not mutate the pool (miner should remove included txs after block finalization).
        """
        items = sorted(self.transaction_map.values(), key=lambda t: self._timestamps.get(t.id, 0))
        if limit:
            return items[:limit]
        return items

    def prune_expired(self, ttl_seconds: int = 60 * 60):
        """
        Remove transactions older than ttl_seconds and release any locks.
        Useful to avoid forever-reserved assets if a tx never makes it into a block.
        """
        now = time.time()
        expired = [txid for txid, ts in self._timestamps.items() if (now - ts) > ttl_seconds]
        for txid in expired:
            self.remove_transaction(txid)
