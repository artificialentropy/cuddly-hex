import time
from typing import Optional, Callable, Dict, List

from .transaction import Transaction


class TransactionPool:
    """
    Transaction pool supporting:
      - Nested outputs: { address: { currency: amount, ... }, ... }
      - Asset transactions (listing, purchase, transfer)
      - Asset locks to prevent double acceptance
      - Optional validation callback to resolve assets
    """

    def __init__(self,
                 resolve_asset_fn: Optional[Callable[[str], object]] = None,
                 validate_on_set: bool = True):
        self.transaction_map: Dict[str, Transaction] = {}
        self.asset_locks: Dict[str, str] = {}   # asset_id -> tx_id
        self._timestamps: Dict[str, float] = {} # tx_id -> insertion time
        self.resolve_asset_fn = resolve_asset_fn
        self.validate_on_set = validate_on_set

    # ---------------------------
    # Core mutators
    # ---------------------------
    def set_transaction(self, transaction: Transaction) -> None:
        """
        Add (or replace) a transaction in the pool with validation.
        Raises Exception on invalid tx or asset conflict.
        """
        tx_id = transaction.id

        # If this tx_id already exists, remove it first to release any old locks.
        if tx_id in self.transaction_map:
            self.remove_transaction(tx_id)

        # 1) Validate first (pure)
        if self.validate_on_set:
            try:
                Transaction.is_valid_transaction(transaction, resolve_asset_fn=self.resolve_asset_fn)
            except Exception as e:
                raise Exception(f"Rejected transaction {tx_id}: validation failed: {e}")

        # 2) Asset lock checks (collect, verify, then reserve atomically)
        asset_infos = []
        meta = getattr(transaction, "metadata", {}) or {}
        for key in ("asset_purchase", "asset_listing", "asset_transfer"):
            v = meta.get(key)
            if v:
                asset_infos.extend(v if isinstance(v, list) else [v])

        # Gather all asset_ids referenced by this transaction
        to_lock: Dict[str, dict] = {}
        for info in asset_infos:
            aid = info.get("asset_id")
            if not aid:
                continue
            to_lock[aid] = info

        # Verify conflicts & ownership first
        for aid, info in to_lock.items():
            existing = self.asset_locks.get(aid)
            if existing and existing != tx_id:
                raise Exception(f"Asset {aid} already reserved by tx {existing} in the pool")

            # Optional owner verification (only when 'from' is provided)
            if self.resolve_asset_fn and "from" in info:
                asset_obj = self.resolve_asset_fn(aid)
                if not asset_obj:
                    raise Exception(f"Asset {aid} not found for tx {tx_id}")
                if asset_obj.owner != info["from"]:
                    raise Exception(f"Asset owner mismatch: expected {info['from']}, got {asset_obj.owner}")

        # Reserve locks atomically
        for aid in to_lock.keys():
            self.asset_locks[aid] = tx_id

        # 3) Insert transaction
        self.transaction_map[tx_id] = transaction
        self._timestamps[tx_id] = time.time()

    def existing_transaction(self, address: str) -> Optional[Transaction]:
        """
        Find a transaction in the pool generated by `address` or affecting `address` in asset metadata.
        """
        for tx in self.transaction_map.values():
            try:
                if tx.input and tx.input.get("address") == address:
                    return tx

                meta = getattr(tx, "metadata", {}) or {}
                for key in ("asset_purchase", "asset_listing", "asset_transfer"):
                    v = meta.get(key)
                    if v:
                        entries = v if isinstance(v, list) else [v]
                        for info in entries:
                            if info.get("from") == address or info.get("to") == address or info.get("owner") == address:
                                return tx
            except Exception:
                continue
        return None

    def get_transactions_by_asset(self, asset_id: str) -> List[Transaction]:
        """Return pool transactions referencing a given asset_id."""
        res = []
        for tx in self.transaction_map.values():
            meta = getattr(tx, "metadata", {}) or {}
            for key in ("asset_purchase", "asset_listing", "asset_transfer"):
                v = meta.get(key)
                if not v:
                    continue
                entries = v if isinstance(v, list) else [v]
                for info in entries:
                    if info.get("asset_id") == asset_id:
                        res.append(tx)
                        break
        return res

    def remove_transaction(self, tx_id: str) -> None:
        """
        Remove transaction and release any asset locks it held.
        """
        tx = self.transaction_map.pop(tx_id, None)
        self._timestamps.pop(tx_id, None)
        if not tx:
            return

        meta = getattr(tx, "metadata", {}) or {}
        for key in ("asset_purchase", "asset_listing", "asset_transfer"):
            v = meta.get(key)
            if not v:
                continue
            entries = v if isinstance(v, list) else [v]
            for info in entries:
                aid = info.get("asset_id")
                if aid and self.asset_locks.get(aid) == tx_id:
                    del self.asset_locks[aid]

    def clear_blockchain_transactions(self, blockchain) -> None:
        """
        Remove transactions already recorded in the blockchain.
        """
        for block in getattr(blockchain, "chain", []):
            for tx_json in getattr(block, "data", []):
                txid = getattr(tx_json, "get", lambda k, d=None: None)("id")
                if txid:
                    self.remove_transaction(txid)

    # ---------------------------
    # Helpers & exporters
    # ---------------------------
    def transaction_data(self) -> List[dict]:
        """Return list of transactions in JSON-serializable form (FIFO order)."""
        items = sorted(self.transaction_map.values(), key=lambda t: self._timestamps.get(t.id, 0))
        return [tx.to_json() for tx in items]

    def to_json(self) -> dict:
        """Dump pool as JSON."""
        return {"transactions": self.transaction_data()}

    def get_transactions_for_mining(self, limit: Optional[int] = None) -> List[Transaction]:
        """
        Return transactions for block mining.
        - Sorted by insertion timestamp (FIFO)
        """
        items = sorted(self.transaction_map.values(), key=lambda t: self._timestamps.get(t.id, 0))
        return items[:limit] if limit else items

    def prune_expired(self, ttl_seconds: int = 3600) -> None:
        """
        Remove transactions older than `ttl_seconds` and release any asset locks.
        """
        now = time.time()
        expired = [txid for txid, ts in self._timestamps.items() if now - ts > ttl_seconds]
        for txid in expired:
            self.remove_transaction(txid)

    # ---------------------------
    # Ergonomics
    # ---------------------------
    def __len__(self) -> int:
        return len(self.transaction_map)

    def __contains__(self, tx_id: str) -> bool:
        return tx_id in self.transaction_map
