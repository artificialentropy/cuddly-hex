# wallet/transaction_pool.py
import time
from typing import Optional, Callable, Dict, List, Any
from collections import defaultdict

from blockchain_backend.utils.config import STARTING_BALANCE, MINING_REWARD_INPUT
from .transaction import Transaction


class TransactionPool:
    """
    Transaction pool supporting:
      - Nested outputs: { address: { currency: amount, ... }, ... }
      - Asset transactions (listing, purchase, transfer)
      - Asset locks to prevent double acceptance
      - Optional validation callback to resolve assets
      - ECONOMIC VALIDATION: chain-aware sufficient-funds checks (prevents double-spend).
    """

    def __init__(
        self,
        resolve_asset_fn: Optional[Callable[[str], object]] = None,
        validate_on_set: bool = True,
        blockchain=None,
    ):
        self.transaction_map: Dict[str, Transaction] = {}
        self.asset_locks: Dict[str, str] = {}    # asset_id -> tx_id
        self._timestamps: Dict[str, float] = {}  # tx_id -> insertion time
        self.resolve_asset_fn = resolve_asset_fn
        self.validate_on_set = validate_on_set
        self.blockchain = blockchain  # used for chain-aware balance checks

    # ---------------------------
    # Core mutators
    # ---------------------------
    def set_transaction(self, transaction: Transaction) -> None:
        """
        Add (or replace) a transaction in the pool with validation.
        Raises Exception on invalid tx, insufficient funds, or asset conflict.
        """
        tx_id = transaction.id

        # Replace-on-set: release any old locks for same id first
        if tx_id in self.transaction_map:
            self.remove_transaction(tx_id)

        # 1) Structural/signature validation (pure)
        if self.validate_on_set:
            try:
                Transaction.is_valid_transaction(
                    transaction, resolve_asset_fn=self.resolve_asset_fn
                )
            except Exception as e:
                raise Exception(f"Rejected transaction {tx_id}: validation failed: {e}")

        # 1.5) Economic validation: enforce on-chain funds including pending pool txs
        if self.blockchain is not None:
            ledger = self._build_ledger_from_chain(self.blockchain)

            # Reserve existing pool txs FIFO
            pending = sorted(
                self.transaction_map.values(),
                key=lambda t: self._timestamps.get(t.id, 0),
            )
            for p in pending:
                self._apply_tx_to_ledger(p.to_json(), ledger)

            # Enforce & reserve the new tx
            self._enforce_sufficient_funds(transaction.to_json(), ledger)
            self._apply_tx_to_ledger(transaction.to_json(), ledger)

        # 2) Asset locks (collect, verify, then reserve atomically)
        asset_infos: List[dict] = []
        meta = getattr(transaction, "metadata", {}) or {}
        for key in ("asset_purchase", "asset_listing", "asset_transfer"):
            v = meta.get(key)
            if v:
                asset_infos.extend(v if isinstance(v, list) else [v])

        to_lock: Dict[str, dict] = {}
        for info in asset_infos:
            aid = info.get("asset_id")
            if not aid:
                continue
            to_lock[aid] = info

        # Verify conflicts & (optionally) ownership
        for aid, info in to_lock.items():
            existing = self.asset_locks.get(aid)
            if existing and existing != tx_id:
                raise Exception(f"Asset {aid} already reserved by tx {existing} in the pool")

            if self.resolve_asset_fn and "from" in info:
                asset_obj = self.resolve_asset_fn(aid)
                if not asset_obj:
                    raise Exception(f"Asset {aid} not found for tx {tx_id}")
                if asset_obj.owner != info["from"]:
                    raise Exception(
                        f"Asset owner mismatch: expected {info['from']}, got {asset_obj.owner}"
                    )

        # Reserve locks
        for aid in to_lock.keys():
            self.asset_locks[aid] = tx_id

        # 3) Insert transaction
        self.transaction_map[tx_id] = transaction
        self._timestamps[tx_id] = time.time()

    def existing_transaction(self, address: str) -> Optional[Transaction]:
        """
        Find a transaction in the pool generated by `address` or affecting `address` in asset metadata.
        """
        for tx in self.transaction_map.values():
            try:
                if tx.input and tx.input.get("address") == address:
                    return tx

                meta = getattr(tx, "metadata", {}) or {}
                for key in ("asset_purchase", "asset_listing", "asset_transfer"):
                    v = meta.get(key)
                    if v:
                        entries = v if isinstance(v, list) else [v]
                        for info in entries:
                            if info.get("from") == address or info.get("to") == address or info.get("owner") == address:
                                return tx
            except Exception:
                continue
        return None

    def get_transactions_by_asset(self, asset_id: str) -> List[Transaction]:
        """Return pool transactions referencing a given asset_id."""
        res: List[Transaction] = []
        for tx in self.transaction_map.values():
            meta = getattr(tx, "metadata", {}) or {}
            for key in ("asset_purchase", "asset_listing", "asset_transfer"):
                v = meta.get(key)
                if not v:
                    continue
                entries = v if isinstance(v, list) else [v]
                for info in entries:
                    if info.get("asset_id") == asset_id:
                        res.append(tx)
                        break
        return res

    def remove_transaction(self, tx_id: str) -> None:
        """Remove a transaction and release any asset locks it held."""
        tx = self.transaction_map.pop(tx_id, None)
        self._timestamps.pop(tx_id, None)
        if not tx:
            return

        meta = getattr(tx, "metadata", {}) or {}
        for key in ("asset_purchase", "asset_listing", "asset_transfer"):
            v = meta.get(key)
            if not v:
                continue
            entries = v if isinstance(v, list) else [v]
            for info in entries:
                aid = info.get("asset_id")
                if aid and self.asset_locks.get(aid) == tx_id:
                    del self.asset_locks[aid]

    def clear_blockchain_transactions(self, blockchain) -> None:
        """Remove transactions already recorded in the blockchain."""
        for block in getattr(blockchain, "chain", []):
            for tx_json in getattr(block, "data", []) or []:
                txid = tx_json.get("id") if isinstance(tx_json, dict) else None
                if txid:
                    self.remove_transaction(txid)

    # ---------------------------
    # Helpers & exporters
    # ---------------------------
    def transaction_data(self) -> List[dict]:
        """Return list of transactions in JSON-serializable form (FIFO order)."""
        items = sorted(self.transaction_map.values(), key=lambda t: self._timestamps.get(t.id, 0))
        return [tx.to_json() for tx in items]

    def to_json(self) -> dict:
        """Dump pool as JSON."""
        return {"transactions": self.transaction_data()}

    def get_transactions_for_mining(self, limit: Optional[int] = None) -> List[Transaction]:
        """Return transactions for block mining, FIFO."""
        items = sorted(self.transaction_map.values(), key=lambda t: self._timestamps.get(t.id, 0))
        return items[:limit] if limit else items

    def prune_expired(self, ttl_seconds: int = 3600) -> None:
        """Remove transactions older than `ttl_seconds` and release any asset locks."""
        now = time.time()
        expired = [txid for txid, ts in self._timestamps.items() if now - ts > ttl_seconds]
        for txid in expired:
            self.remove_transaction(txid)

    # ---------------------------
    # Ergonomics
    # ---------------------------
    def __len__(self) -> int:
        return len(self.transaction_map)

    def __contains__(self, tx_id: str) -> bool:
        return tx_id in self.transaction_map

    # ===========================
    # Internal ledger utilities
    # ===========================
    @staticmethod
    def _ensure_seed(ledger, address: str) -> None:
        """Seed a newly seen address with configured starting balance (COIN)."""
        if "COIN" not in ledger[address]:
            ledger[address]["COIN"] = int(STARTING_BALANCE)

    @classmethod
    def _build_ledger_from_chain(cls, blockchain) -> Dict[str, Dict[str, int]]:
        """
        Build a balance sheet from the current chain.
        Per address, per currency. Seeds with STARTING_BALANCE on first sight.
        """
        ledger: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))

        chain = getattr(blockchain, "chain", None) or []
        # skip genesis (index 0)
        for block in chain[1:]:
            for tx in getattr(block, "data", []) or []:
                tx_in: Dict[str, Any] = tx.get("input", {}) or {}
                tx_out: Dict[str, Dict[str, int]] = tx.get("output", {}) or {}

                # Reward (mint): credit outputs directly
                if tx_in == MINING_REWARD_INPUT:
                    for out_addr, cm in (tx_out or {}).items():
                        cls._ensure_seed(ledger, out_addr)
                        for cur, amt in (cm or {}).items():
                            ledger[out_addr][cur] += int(amt)
                    continue

                sender = tx_in.get("address")
                if sender:
                    cls._ensure_seed(ledger, sender)

                # Credits to recipients (excluding sender's change)
                for out_addr, cm in (tx_out or {}).items():
                    if out_addr == sender:
                        continue
                    cls._ensure_seed(ledger, out_addr)
                    for cur, amt in (cm or {}).items():
                        ledger[out_addr][cur] += int(amt)

                # Debits for sender: sum amounts to others
                if sender:
                    sent = defaultdict(int)
                    for out_addr, cm in (tx_out or {}).items():
                        if out_addr == sender:
                            continue
                        for cur, amt in (cm or {}).items():
                            sent[cur] += int(amt)
                    for cur, amt in sent.items():
                        ledger[sender][cur] -= int(amt)

        return ledger

    @classmethod
    def _enforce_sufficient_funds(cls, tx: Dict[str, Any], ledger: Dict[str, Dict[str, int]]) -> None:
        """
        Raise if the sender doesn't have enough on-chain balance for the amounts
        sent to OTHER addresses (per currency). Zero-sum and reward txs are allowed.
        """
        tx_in: Dict[str, Any] = tx.get("input", {}) or {}
        tx_out: Dict[str, Dict[str, int]] = tx.get("output", {}) or {}

        # Reward mints are fine
        if tx_in == MINING_REWARD_INPUT:
            return

        sender = tx_in.get("address")
        if not sender:
            return  # nothing to enforce if there's no economic sender

        # Zero-sum metadata tx (e.g., listings)
        has_any_amount = any(
            int(v) for addr_map in (tx_out or {}).values() for v in (addr_map or {}).values()
        )
        if not has_any_amount:
            return

        # Ensure sender exists in ledger
        cls._ensure_seed(ledger, sender)

        # Compute per-currency amounts sent to others
        sent = defaultdict(int)
        for out_addr, cm in (tx_out or {}).items():
            if out_addr == sender:
                continue
            for cur, amt in (cm or {}).items():
                sent[cur] += int(amt)

        # Enforce per-currency sufficient balance
        for cur, amt in sent.items():
            if ledger[sender][cur] < amt:
                raise Exception(
                    f"Insufficient on-chain funds for {cur}: have={ledger[sender][cur]} need={amt}"
                )

    @classmethod
    def _apply_tx_to_ledger(cls, tx: Dict[str, Any], ledger: Dict[str, Dict[str, int]]) -> None:
        """Mutate ledger by applying the tx effects (reservation/apply)."""
        tx_in: Dict[str, Any] = tx.get("input", {}) or {}
        tx_out: Dict[str, Dict[str, int]] = tx.get("output", {}) or {}

        if tx_in == MINING_REWARD_INPUT:
            for out_addr, cm in (tx_out or {}).items():
                cls._ensure_seed(ledger, out_addr)
                for cur, amt in (cm or {}).items():
                    ledger[out_addr][cur] += int(amt)
            return

        sender = tx_in.get("address")

        # Credits to recipients (excluding sender's change)
        for out_addr, cm in (tx_out or {}).items():
            if out_addr == sender:
                continue
            cls._ensure_seed(ledger, out_addr)
            for cur, amt in (cm or {}).items():
                ledger[out_addr][cur] += int(amt)

        # Debits for sender: sum amounts to others
        if sender:
            cls._ensure_seed(ledger, sender)
            sent = defaultdict(int)
            for out_addr, cm in (tx_out or {}).items():
                if out_addr == sender:
                    continue
                for cur, amt in (cm or {}).items():
                    sent[cur] += int(amt)
            for cur, amt in sent.items():
                ledger[sender][cur] -= int(amt)
